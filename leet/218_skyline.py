#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
https://leetcode.com/problems/the-skyline-problem/#/description

Difficulty: Hard
Total Accepted: 42K
Total Submissions: 155.9K
"""
import pytest


def add_line(lines, *new_lines):
    for l in new_lines:
        if lines:
            last = lines[-1]
            if last[1] == l[1]:
                continue
            if last[0] == l[0]:
                if last[1] < l[1]:
                    lines.pop()
                else:
                    continue  # pragma: no cover
        lines.append(l)


def add_building(buildings, *new_buidings):
    for nb in new_buidings:
        if nb[0] == nb[1]:
            continue
        if not buildings:
            buildings.append(nb)
            continue
        at = 0
        for i in range(len(buildings) - 1, -1, -1):
            if buildings[i][0] > nb[0]:
                at = i + 1
                break
        buildings.insert(at, nb)


def normalize(buildings):
    buildings.reverse()
    ret = []
    while len(buildings) > 1:
        a = buildings.pop()
        b = buildings.pop()
        if b[0] > a[1]:
            # not adjacent
            ret.append(a)
            add_building(buildings, b)
        else:  # possible cases of how 2 buildings can overlap
            if b[1] >= a[1]:
                if b[2] > a[2]:
                    # shape like:
                    #    #
                    #   *#
                    ret.append([a[0], b[0], a[2]])
                    add_building(buildings, b)
                else:
                    # shape like:
                    #    *
                    #    *#
                    ret.append(a)
                    add_building(buildings, [
                        a[1], b[1], b[2],
                    ])
            else:
                if b[2] <= a[2]:
                    # b is completely shadowed by a
                    add_building(buildings, a)
                else:
                    # shape like:
                    #     #
                    #    *#*
                    ret.append([a[0], b[0], a[2]])
                    add_building(
                        buildings,
                        [b[1], a[1], a[2]],
                        b,
                    )
    ret.extend(buildings)
    return ret


class Solution(object):

    def getSkyline(self, buildings):
        """
        :type buildings: List[List[int]]
        :rtype: List[List[int]]
        """
        if not buildings:
            return []
        while True:
            buildings = normalize(buildings)
            # try to get line endpoints
            lines = []
            done = True
            for i, a in enumerate(buildings[:-1]):
                b = buildings[i + 1]
                if b[0] < a[1]:
                    # there are still overlaps; should further normalize
                    done = False
                    break
                else:
                    add_line(lines, [a[0], a[2]])
                    if b[0] > a[1]:
                        # the 2 buildings are separate
                        # add a line of height 0 to connect them
                        add_line(lines, [a[1], 0])
            if done:
                last = buildings[-1]
                add_line(lines, [last[0], last[2]], [last[1], 0])
                return lines


TESTCASES = [
    # edge cases
    [
        [], [],
    ],
    [
        [[0, 1, 1]], [[0, 1], [1, 0]],
    ],
    # basic cases
    [
        [[0, 2, 1], [1, 3, 2]], [[0, 1], [1, 2], [3, 0]],
    ],
    [
        [[0, 3, 1], [1, 2, 2]], [[0, 1], [1, 2], [2, 1], [3, 0]],
    ],
    [
        [[0, 3, 2], [1, 2, 1]], [[0, 2], [3, 0]],
    ],
    [
        [[0, 2, 2], [1, 3, 1]], [[0, 2], [2, 1], [3, 0]],
    ],
    [
        [[0, 3, 1], [1, 2, 1]], [[0, 1], [3, 0]],
    ],
    [
        [[0, 1, 1], [1, 2, 1]], [[0, 1], [2, 0]],
    ],
    [
        [[0, 1, 1], [2, 3, 2]], [[0, 1], [1, 0], [2, 2], [3, 0]],
    ],
    [
        [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]],
        [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]],
    ],
    [
        [[2, 4, 7], [2, 4, 5], [2, 4, 6]], [[2, 7], [4, 0]],
    ],
    [
        [[3, 7, 8], [3, 8, 7], [3, 9, 6], [3, 10, 5], [
            3, 11, 4], [3, 12, 3], [3, 13, 2], [3, 14, 1]],
        [[3, 8], [7, 7], [8, 6], [9, 5], [10, 4],
            [11, 3], [12, 2], [13, 1], [14, 0]],
    ],
    [
        [[2302, 521688, 394023], [10396, 840253, 671644], [22633, 740538, 553794], [33104, 968793, 842909], [33566, 749635, 5965], [34724, 567056, 645908], [38397, 976841, 114857], [41596, 756920, 756376], [42323, 568307, 228042], [50775, 387740, 218538], [61200, 430269, 411341], [76753, 128525, 68496], [79373, 804949, 468753], [81162, 945496, 354439], [83491, 488856, 82703], [83809, 615534, 135829], [91172, 98128, 912707], [95567, 530117, 871928], [101588, 239875, 783665], [103078, 590123, 714837], [103699, 628880, 670340], [106349, 601107, 634192], [114080, 857023, 390674], [127529, 156548, 766654], [137072, 782287, 221710], [139108, 668109, 706758], [141344, 450521, 304555], [147516, 954217, 783723], [147543, 822521, 605998], [152329, 865672, 871749], [155260, 725627, 85938], [157561, 672597, 545652], [161181, 795511, 915546], [165951, 657821, 612662], [168914, 648886, 559332], [176974, 403872, 328905], [177537, 816528, 832605], [178894, 994383, 245167], [179305, 756396, 288023], [205335, 698945, 602609], [212822, 529316, 389301], [229320, 301090, 412311], [237431, 802167, 532853], [241799, 432691, 875928], [267123, 868784, 764314], [282273, 563128, 851718], [282813, 337595, 839969], [293252, 872759, 547091], [294475, 588008, 544742], [310848, 575608, 8816], [313543, 702058, 619704], [  # noqa
            325577, 888559, 912371], [330608, 552502, 212597], [332655, 726247, 322151], [356504, 578275, 261647], [357551, 420868, 893362], [358688, 445854, 822451], [359730, 411661, 261651], [367095, 705352, 206884], [368783, 930183, 526370], [369792, 438228, 17430], [372046, 918137, 417386], [384795, 779748, 89023], [385884, 954729, 987280], [390022, 543892, 949489], [419733, 989088, 752157], [422927, 835825, 640265], [424969, 556942, 208378], [437284, 468376, 167867], [441169, 712058, 143721], [452677, 730601, 452847], [453781, 899636, 4472], [455288, 861562, 314782], [465055, 497234, 610455], [468848, 953512, 993894], [564747, 800626, 521581], [569498, 632750, 102677], [580055, 865963, 52393], [590629, 767024, 328585], [594183, 729278, 559762], [633995, 710904, 837755], [637204, 972619, 56114], [640775, 884992, 894921], [643236, 732511, 895800], [645857, 777086, 452259], [663772, 852581, 904928], [665117, 673222, 153191], [673219, 810151, 736462], [683913, 859158, 474705], [691729, 895602, 974107], [695824, 730590, 525683], [744533, 979535, 858112], [751142, 866326, 818831], [758572, 830775, 838557], [789925, 989097, 188384], [823175, 949879, 924869], [871352, 970590, 706320], [874124, 958946, 58789], [879565, 947487, 883632], [883183, 910077, 337730], [888036, 936787, 995802]],  # noqa
        [[2302, 394023], [10396, 671644], [33104, 842909], [91172, 912707], [98128, 871928], [161181, 915546], [385884, 987280], [  # noqa
            468848, 993894], [888036, 995802], [936787, 993894], [953512, 987280], [954729, 858112], [979535, 752157], [989088, 245167], [994383, 0]],  # noqa
    ]
]


@pytest.mark.parametrize('args,expected', TESTCASES)
def test(args, expected):
    actual = Solution().getSkyline(list(args))
    assert actual == expected
